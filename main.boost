#include <iostream>
#include <stdexcept>
#include <boost/program_options.hpp>
#include "PPMC.h"
#include "FileWriter.h"
#include "FileReader.h"
#include "PPMCCompressor.h"
#include "PPMCUncompressor.h"

using namespace ppmc;
using namespace util;
using namespace std;

namespace po = boost::program_options;

class bad_arguments:public exception {};

int main(int argc, char* argv[]) {
	
	
	po::options_description desc("Opciones");
	size_t order;
	size_t buffer;
	string input;
	string output;
	desc.add_options()
		("c", po::value< string >(&input), "Archivo de entrada")
		("x", po::value< string >(&input), "Archivo de entrada")
		("t", po::value< string >(&output), "Archivo de salida")
		("o", po::value<size_t>(&order)->default_value(3), "Orden")
		("b", po::value<size_t>(&buffer)->default_value(2048), "Buffer entrada/salida")
	;
//try
	po::variables_map vm;
	po::store(po::parse_command_line(argc, argv, desc), vm);
	po::notify(vm);    
// catch

	if (! vm.count("c") && ! vm.count("x") ) {
		cout << "Debe indicar un archivo de entrada." << endl;
		//return 1;
	}

	if (!vm.count("t")) {
		if (vm.count("c")) {
			output += ".xxx";
		} else {
			output = output.substr(0,-4);
		}
	}
	
	cout << "vamos a ";
	if (vm.count("c")) {
		cout << "comprimir ";
	} else {
		cout << "descomprimir ";
	}
	
	cout << input << " en " << output << " con orden " << order;
	cout << " y buffer " << buffer << endl;
	return 0;
	try {
		FileReader in(input.c_str(), buffer);
		FileWriter out(output.c_str(), buffer);
		
		
		if (vm.count("c")) {
			PPMCCompressor c(&in,&out);
			c.compress();
		} else if(vm.count("x")) {
			PPMCUncompressor d(&in,&out);
			d.uncompress();
		} else {
			throw exception(); // bad bad bad
		}
	} catch (invalid_argument& e) {
		cerr << "Modo " << e.what() << " no reconocido" << endl;
		cerr << "Debe elegir \"c\" para comprimir o \"x\" para descomprimir" << endl;
		return 1;
	} catch (bad_arguments& e) {
		cerr << "Cantidad de argumentos incorrecta" << endl;
		cerr << "Modo de uso: " << argv[0] << "  [c|x] entrada salida" << endl;
		return 2;
	} catch (exception& e) {
		cerr << "Error interno: " << e.what() << endl;
		return 3;
	}

	return 0;
}
